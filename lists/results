Results list (* signifies contributions)



* lamarcas results:
agree:

heap:
+- 4 heap has fewer instructions than base
+- shape of instr graph
+- general idea of level 1 graph
+- same shape of cycles graph

merge:

+- copy back and forth works
+- bitonic works (sedgewick)
+- inline faster
+- offset by cachesize/2 works
+- tiled mergesort works
+- multi-mergesort redues cache misses
+- cache miss shapes exactly right
+- wobble in base mergesort

quick:
+- 20\% increase in instructions is what we got
+= shape of instructions exactly right
+- new use of insertion sort is lower cache misses
+- all quicksorts incur few misses
+- base fewer than two misses (we say 1)
+- .25 fewer misses in tuned
+ flat curve: cant disporve. looks like it


disagree:

heap:

+- what about in-place vs out-of-place

merge:

- efficient inline search not as good as insertion sort
- algorithm N dont make sense
- base algorithm instruction count is roughly the same as heapsort, not half
- unable to use a tagged system in multi-mergesort, so have much higher instruction count
- multi-mergesort doesnt work, as the instruction count increase blanks out the reduction in cache misses
- tiled mergesort increase level1 misses, a lot. much better performance
- single tiled peforms much worse than base
- as does multi-mergesort

quick:

+- we reckon its more efficient to use insertion sort as in tuned quicksort



* results


overall:
*-  it takes a 4096 entry predictor to beat the bimodal (even the smallest) ie heapsort
*- 2 level adaptive can overcome the erratic behaviour of binary search
*- due to replacement policy, direct mapped can beat fully associative, ie multi-mergesort, all through quicksort

on2 overall results:
- bubblesort faster than bubblesort2
- shakersort faster than bubblesorts and shakersort2
- insertion sort best, followed by selection

*on2 cache results:
- shakersort has temporal reuse
- insertion sort has very good temporal resuse
- generally bad reuse

on2 branch results:
*- insertion sort has 1 misprediction
*- selction sort has Hn+1 misprediction
*- selection sort is much worse in cache and instructions than shakersort, but much faster due to bubblesorts terrible branhc prediction


heap results:
*- base flat-lines for longer due to being in-place (not observed by lamarca)
*- predictions go in a curve
*- you might be better off using a semi-static predictor when dealing with random data
*- 8 heap worse than 4 heap


merge results:
*- leevel 1 needs to be taken into account
*- algorithm S is 15% faster than N
*- double tiled is the best
*- multi is too expensive
*- algorithm n and s are bad cache performers
- multi-mergesort has regualr access patterns in the k-way merge

quick rsults:



new techniques:
*: heapsort sentinel
- reorders the moves during the destruction of the heap in base heapsort so that a sentinel isnt required
*: merging with a different intial size to avoid the final copy back (did LaMarca suggest this. not in the phd)?




