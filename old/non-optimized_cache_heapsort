#include "cache_sorts.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>

#define HEAP_SIZE 8 /* never set this to 1 */

/* these days we index from 0 - N-1
* the rightmost child is (parent + 1)*heapsize
* the parent = (child - 1) / heapsize 
*
* actually, we go from leftchild, which is (parent * heapsize) + 1
* parent = (child - 1) / heapsize
*/


static int
check_heap_property(unsigned int a[], int N)
{
	int parent;
	int i;
	for(parent = 0; parent < N/HEAP_SIZE+1; parent++)
	{
		int l = parent*HEAP_SIZE + 1;
/*		printf("checking children of %d (a[parent] = %d\n", parent, a[parent]);*/
		for(i = 0; i < HEAP_SIZE; i++)
		{
/*			printf("checking child %d (a[%d] = %d)\n", HEAP_SIZE-i-1, r-i, a[r-i]);*/
			if (l+i >= N)
			{
/*				printf("finsihing\n");*/
				break;
			}
			if (a[parent] > a[l+i])
			{
				printf("FAIL: node %d (%d) is greater than child %d (node %d (%d)) \n", parent, a[parent], i, l+i, a[l+i]);
				return -1;
			}
		}	
	}
	return 0;
}



static void
fix_up(unsigned int heap[], int child)
{
	int parent;
/*	printf("fixup: %d\n ", child); */
/*	printf("next child = %d, parent = %d, heap[child] = %d, heap[parent] = %d\n", child, ((child)/HEAP_SIZE), heap[child], heap[((child)/HEAP_SIZE)]);*/
	while(less(heap[child], heap[parent = ((child-1)/HEAP_SIZE)]))
	{
/*		printf("child = %d, parent = %d, heap[child] = %d, heap[parent] = %d\n", child, parent, heap[child], heap[parent]);*/

		exch(heap[child], heap[parent]);
		child = parent;
/*		printf("next child = %d, parent = %d, heap[child] = %d, heap[parent] = %d\n", child, ((child)/HEAP_SIZE), heap[child], heap[((child)/HEAP_SIZE)]);*/
	}
/*	printf("------------------------------------------------------------------\n");*/
}

static void
fix_down(unsigned int heap[], int parent, int N)
{
	int i;
	int child;
	int child2;
/*	printf("fixdown when N = %d\n", N); */
	while(parent*HEAP_SIZE+1 < N) /* see if it has any children */
	{
		child = parent*HEAP_SIZE + 1; /* this gets the rightmost node */
		child2 = child;

/*		printf("parent (node %d) = %d\n", parent, heap[parent]); */

		/* see if it has more than 1 child - checparent which child is larger */
		for(i = 0; i < HEAP_SIZE; i++)
		{
			int current = child2 + i;
			
/*			printf("current (node %d) = %d\n", current, heap[current]); */
/*			printf("comparing heap[%d] (%d) and heap[%d] (%d)\n", current, heap[current], child, heap[child]); */
/*			if (current >= N)
			{
				break;
			} 
*/			
			if (less(heap[current], heap[child]))
			{
				child = current;
			}
/*			printf("child is now %d\n", child); */
		}

/*		printf("child (node %d) = %d\n", child, heap[child]); */
		/* when the larger child isnt large enough to be promoted, stop */
		if (!less(heap[child], heap[parent])) break;

		/* move down */
		exch(heap[parent], heap[child]); 
		parent = child;
	}
}

void
cache_heapsort(unsigned int a[], int l, int r)
{
	int N = (r-l)+1;
	unsigned int* heap_data = malloc((N + HEAP_SIZE) * sizeof(unsigned int));
	unsigned int* heap = &heap_data[HEAP_SIZE - 1];
	int i;
	unsigned int length = 0;

	int sentinel_count = HEAP_SIZE - (N % HEAP_SIZE) + 1; 

	/* add sentinels for fixdown */
	for(i = 0; i < sentinel_count; i++)
	{
/*		printf("adding a sentinel (%d) at position %d\n", UINT_MAX, N+i); */
		heap[N + i] = UINT_MAX;
	} 

	/* first build the heap */
	for(i = 0; i < N; i++)
	{
		heap[length] = a[i];
		fix_up(heap, length);
/*		if (check_heap_property(heap, length) == -1)*/
/*		{*/
/*			print_int_array(heap, length+1, "fixing up", 0, length, i);*/
/*			exit(1);*/
/*		}*/
		length++;
	}

	i = 0;
	/* now pick the smallest off it */
	while(length > 0)
	{
		a[i++] = heap[0];
		heap[0] = heap[length-1];
		heap[length-1] = UINT_MAX;
		fix_down(heap, 0, length);
		length--;
	}

	free(heap_data);
}
